<?php

namespace App\Http\Controllers;

use App\Models\Apartment;
use App\Models\AuditLog;
use App\Models\InventoryItem;
use App\Models\Project;
use App\Models\ProjectFloor;
use App\Models\ProjectInventoryItem;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;
use Illuminate\Validation\Rule;
use Illuminate\Validation\ValidationException;

class ProjectController extends Controller
{
    public function createProject(Request $request){
        $audit=new AuditLog();
        $audit->user_id=auth()->id();
        $audit->event='Create';
        $audit->entity_type='Project';
        $audit->details='Creating project failed';
        $audit->save();
        $audit->record='PRJ-'.str_pad(auth()->id(), 5, '0', STR_PAD_LEFT).'-'.$audit->id;
        $audit->save();
         $validated = $request->validate([
            // project
            'project_name' => ['required', 'string', 'max:255'],
            'project_code' => ['nullable', 'string', 'max:50','unique:projects,code'],
            'city' => ['required', 'string', 'max:100'],
            'area' => ['nullable', 'string', 'max:150'],
            'address' => ['nullable', 'string', 'max:255'],
            'start_date' => ['nullable', 'date'],
            'estimated_completion_date' => ['nullable', 'date'],
            'notes' => ['nullable', 'string', 'max:2000'],

            // floors generator input
            'floor_count' => ['required', 'integer', 'min:1', 'max:200'],

            // floors/units payload generated by JS
            'floors' => ['required', 'array'],
            'floors.*.units' => ['required', 'array', 'min:1'],

            'floors.*.units.*.unit_code' => ['nullable', 'string', 'max:50'],
            'floors.*.units.*.bedrooms' => ['nullable', 'integer', 'min:0', 'max:20'],
            'floors.*.units.*.bathrooms' => ['nullable', 'integer', 'min:0', 'max:20'],
            'floors.*.units.*.area_m2' => ['nullable', 'numeric', 'min:0'],
            'floors.*.units.*.price' => ['nullable', 'numeric', 'min:0'],
            'floors.*.units.*.status' => ['nullable', 'in:available,reserved,sold'],
            'floors.*.units.*.note' => ['nullable', 'string', 'max:1000'],

            // materials (we validate; storing depends on your DB tables)
            'materials' => ['nullable', 'array'],
            'materials.item_id' => ['nullable', 'array'],
            'materials.item_id.*' => ['nullable', 'integer', 'exists:inventory_items,id'],
            'materials.qty' => ['nullable', 'array'],
            'materials.qty.*' => ['nullable', 'numeric', 'min:0'],
            'materials.unit' => ['nullable', 'array'],
            'materials.unit.*' => ['nullable', 'string', 'max:20'],
        ]);

        return DB::transaction(function () use ($request, $validated,$audit) {
            // ✅ Create Project (map your columns)
            $project = Project::create([
                'name' => $validated['project_name'],
                'code' => $validated['project_code'] ?? null,
                'city'=>$validated['city']??null,
                'area'=>$validated['area']??null,
                'address' => $validated['address'] ?? null,
                'estimated_completion_date' => $validated['estimated_completion_date'] ?? null,
                'notes' => $validated['notes'] ?? null,
                'status' => 'planned',
                'manager_user_id' => Auth::id(),
            ]);
            //STOCK CONTROL!!
            $materials = $request->input('materials', []);
            $itemIds = $materials['item_id'] ?? [];
            $qtys    = $materials['qty'] ?? [];
            $units   = $materials['unit'] ?? [];
            $notes   = $materials['note'] ?? []; // optional if you later add column

            // clean rows (remove empty item selections)
            $rows = [];
            for ($i = 0; $i < count($itemIds); $i++) {
                $id = $itemIds[$i] ?? null;
                $qty = $qtys[$i] ?? null;
                $unit = $units[$i] ?? null;

                if (!$id) continue; // skip empty row

                $rows[] = [
                    'inventory_item_id' => (int)$id,
                    'quantity_needed' => (float)$qty,
                    'unit' => (string)$unit,
                ];
            }

            if (count($rows)) {
                // prevent duplicates (same item twice) by aggregating
                $aggregated = [];
                foreach ($rows as $r) {
                    $key = $r['inventory_item_id'];
                    if (!isset($aggregated[$key])) {
                        $aggregated[$key] = $r;
                    } else {
                        $aggregated[$key]['quantity_needed'] += $r['quantity_needed'];
                    }
                }
                $rows = array_values($aggregated);

                // lock inventory rows to avoid race conditions
                $inventory = InventoryItem::whereIn('id', array_column($rows, 'inventory_item_id'))
                    ->lockForUpdate()
                    ->get()
                    ->keyBy('id');

                $errors = [];

                foreach ($rows as $r) {
                    $inv = $inventory->get($r['inventory_item_id']);

                    if (!$inv) {
                        $errors["materials.item_id"][] = "Selected material not found.";
                        continue;
                    }

                    // unit enforcement (must match DB unit)
                    if ($inv->unit && $r['unit'] !== $inv->unit) {
                        $errors["materials.unit"][] = "Unit mismatch for {$inv->name}.";
                    }

                    $need = $r['quantity_needed'];
                    if ($need <= 0) {
                        $errors["materials.qty"][] = "Quantity must be greater than 0 for {$inv->name}.";
                        continue;
                    }

                    if ($need > $inv->quantity) {
                        $errors["materials.qty"][] = "Not enough stock for {$inv->name}. Needed {$need} {$inv->unit}, available {$inv->quantity} {$inv->unit}.";
                        continue;
                    }
                }

                if (!empty($errors)) {
                    throw ValidationException::withMessages($errors);
                }

                // apply stock updates + insert pivot rows
                foreach ($rows as $r) {
                    $inv = $inventory->get($r['inventory_item_id']);

                    $newQty = $inv->quantity - $r['quantity_needed'];

                    $inv->quantity = $newQty;
                    $inv->is_out_of_stock = ($newQty <= 0);
                    $inv->save();

                    ProjectInventoryItem::create([
                        'project_id' => $project->id,
                        'inventory_item_id' => $inv->id,
                        'quantity_needed' => $r['quantity_needed'],
                        'unit' => $inv->unit ?? $r['unit'],
                    ]);
                }
            }   

            // ✅ Floors + Apartments
            foreach ($validated['floors'] as $floorNumber => $floorData) {
                $floor = ProjectFloor::create([
                    'project_id' => $project->id,
                    'floor_number' => (int) $floorNumber,
                ]);

                foreach ($floorData['units'] as $unit) {
                    Apartment::create([
                        'project_id' => $project->id,
                        'floor_id' => $floor->id,
                        'unit_number' => $unit['unit_code'] ?? null,
                        'bedrooms' => $unit['bedrooms'] ?? 0,
                        'bathrooms' => $unit['bathrooms'] ?? 0,
                        'area_sqm' => $unit['area_m2'] ?? 0,
                        'price_total' => $unit['price'] ?? 0,
                        'status' => $unit['status'] ?? 'available',
                        'notes' => $unit['note'] ?? null,
                    ]);
                }
            }

            // ✅ Materials: only store if you already have a table for it.
            // If you have something like project_materials table, tell me its name/columns and I’ll wire it.
            // For now we just ignore storing it safely.
            $audit->details='Creating project succeeded. Project Code: '.$project->code.' Project Name: '.$project->name;
            $audit->save();
            return redirect()
                ->route('apartments.overview') // or your projects list route
                ->with('success', 'Project created successfully.');
        });
        
    }
    public function editProject(Request $request,Project $project){
            $audit=new AuditLog();
        $audit->user_id=auth()->id();
        $audit->event='Update';
        $audit->entity_type='Project';
        $audit->details='Updating project ('.$project->name.') failed';
        $audit->save();
        $audit->record='PRJ-'.str_pad(auth()->id(), 5, '0', STR_PAD_LEFT).'-'.$audit->id;
        $audit->save();
        $validated = $request->validate([
        // project fields
        'project_name' => ['required', 'string', 'max:255'],
        'project_code' => [
            'nullable', 'string', 'max:60',
            Rule::unique('projects', 'code')->ignore($project->id),
        ],
        'city' => ['required', 'string', 'max:255'],
        'area' => ['nullable', 'string', 'max:255'],
        'address' => ['nullable', 'string', 'max:255'],
        'start_date' => ['nullable', 'date'],
        'estimated_completion_date' => ['nullable', 'date'],
        'notes' => ['nullable', 'string'],

        // materials arrays
        'materials' => ['nullable', 'array'],
        'materials.item_id' => ['nullable', 'array'],
        'materials.qty' => ['nullable', 'array'],
        'materials.unit' => ['nullable', 'array'],
        'materials.note' => ['nullable', 'array'],

        // floors/units
        'floors' => ['nullable', 'array'],
        'floors.*.id' => ['nullable', 'integer'],
        'floors.*.floor_number' => ['nullable', 'integer', 'min:1'],

        'floors.*.units' => ['nullable', 'array'],
        'floors.*.units.*.id' => ['nullable', 'integer'],
        'floors.*.units.*.unit_code' => ['nullable', 'string', 'max:50'],
        'floors.*.units.*.bedrooms' => ['nullable', 'integer', 'min:0'],
        'floors.*.units.*.bathrooms' => ['nullable', 'integer', 'min:0'],
        'floors.*.units.*.area_m2' => ['nullable', 'numeric', 'min:0'],
        'floors.*.units.*.price' => ['nullable', 'numeric', 'min:0'],
        'floors.*.units.*.status' => ['nullable', Rule::in(['available', 'reserved', 'sold'])],
        'floors.*.units.*.note' => ['nullable', 'string', 'max:255'],
    ]);

    return DB::transaction(function () use ($validated, $request, $project,$audit) {

        // ---------------------------
        // A) Update project main info
        // ---------------------------
        $project->update([
            'name' => $validated['project_name'],
            'code' => $validated['project_code'] ?? null,
            'city' => $validated['city'] ?? null,
            'area' => $validated['area'] ?? null,
            'address' => $validated['address'] ?? null,
            'start_date' => $validated['start_date'] ?? null,
            'estimated_completion_date' => $validated['estimated_completion_date'] ?? null,
            'notes' => $validated['notes'] ?? null,

        ]);

        // --------------------------------------------
        // B) MATERIALS + STOCK CONTROL (important part)
        // --------------------------------------------

        // 1) Restore previously reserved quantities back to inventory
        $project->load('inventoryUsages'); // ProjectInventoryItem rows

        foreach ($project->inventoryUsages as $usage) {
            $inv = InventoryItem::where('id', $usage->inventory_item_id)->lockForUpdate()->first();
            if (!$inv) continue;

            $restoreQty = (float) ( $usage->quantity_needed ?? 0);

            if ($restoreQty > 0) {
                $inv->quantity = (float)$inv->quantity + $restoreQty;
                $inv->is_out_of_stock = ((float)$inv->quantity <= 0);
                $inv->save();
            }
        }

        // 2) Delete old usages (we’ll recreate from submitted form)
        DB::table('project_inventory_items')->where('project_id', $project->id)->delete();

        // 3) Build new usages from request arrays
        $itemIds = $request->input('materials.item_id', []);
        $qtys    = $request->input('materials.qty', []);
        $units   = $request->input('materials.unit', []);
        $notes   = $request->input('materials.note', []);

        // normalize rows
        $rows = [];
        for ($i = 0; $i < count($itemIds); $i++) {
            $iid = $itemIds[$i] ?? null;
            $q   = $qtys[$i] ?? null;
            if (!$iid || $q === null || $q === '') continue;

            $rows[] = [
                'inventory_item_id' => (int)$iid,
                'quantity_needed' => (float)$q,
                'unit' => (string)($units[$i] ?? ''),
                'note' => (string)($notes[$i] ?? ''),
            ];
        }

        // 4) Validate stock availability then deduct
        foreach ($rows as $r) {
            $inv = InventoryItem::where('id', $r['inventory_item_id'])->lockForUpdate()->firstOrFail();

            // optional: enforce unit match
            // if ($r['unit'] !== $inv->unit) { ... }

            $need = (float)$r['quantity_needed'];
            $available = (float)$inv->quantity;

            if ($need > $available) {
                // rollback transaction by throwing validation-like error
                abort( back()
                    ->withErrors(["materials" => "Not enough stock for {$inv->name}. Needed {$need} {$inv->unit}, available {$available} {$inv->unit}."])
                    ->withInput()
                );
            }

            // deduct now
            $inv->quantity = $available - $need;
            $inv->is_out_of_stock = ((float)$inv->quantity <= 0);
            $inv->save();

            DB::table('project_inventory_items')->insert([
                'project_id' => $project->id,
                'inventory_item_id' => $inv->id,
                'quantity_needed' => $need,
                'unit' => $inv->unit,                 // keep DB truth
                'created_at' => now(),
                'updated_at' => now(),
            ]);
        }

        // --------------------------------------------
        // C) FLOORS + APARTMENTS UPSERT + DELETE REMOVED
        // --------------------------------------------
        $floorsInput = $request->input('floors', []);
        $keepFloorIds = [];

        foreach ($floorsInput as $floorIndex => $floorData) {
            $floorId = $floorData['id'] ?? null;
            $floorNumber = $floorData['floor_number'] ?? ($floorIndex + 1);

            /** @var ProjectFloor $floor */
            if ($floorId) {
                $floor = ProjectFloor::where('project_id', $project->id)->where('id', $floorId)->firstOrFail();
                $floor->floor_number = $floorNumber;
                $floor->save();
            } else {
                $floor = ProjectFloor::create([
                    'project_id' => $project->id,
                    'floor_number' => $floorNumber,
                ]);
            }

            $keepFloorIds[] = $floor->id;

            // apartments / units
            $unitsInput = $floorData['units'] ?? [];
            $keepUnitIds = [];

            foreach ($unitsInput as $unitIndex => $u) {
                // If user left the row empty, skip creating it
                $unitCode = $u['unit_code'] ?? null;
                if (!$unitCode) continue;

                $apartmentId = $u['id'] ?? null;

                if ($apartmentId) {
                    $apt = Apartment::where('project_id', $project->id)
                        ->where('id', $apartmentId)
                        ->firstOrFail();
                } else {
                    $apt = new Apartment();
                    $apt->project_id = $project->id;
                }

                $apt->floor_id = $floor->id;

                // IMPORTANT: map your JS field names to DB columns
                $apt->unit_number = $unitCode;                     // DB: unit_number
                $apt->bedrooms = $u['bedrooms'] ?? null;
                $apt->bathrooms = $u['bathrooms'] ?? null;
                $apt->area_sqm = $u['area_m2'] ?? null;            // DB: area_sqm
                $apt->price_total = $u['price'] ?? null;           // DB: price_total
                $apt->status = $u['status'] ?? 'available';
                $apt->notes = $u['note'] ?? null;                  // DB: notes

                $apt->save();
                $keepUnitIds[] = $apt->id;
            }

            // delete removed apartments from this floor
            Apartment::where('project_id', $project->id)
                ->where('floor_id', $floor->id)
                ->when(count($keepUnitIds) > 0, fn($q) => $q->whereNotIn('id', $keepUnitIds))
                ->when(count($keepUnitIds) === 0, fn($q) => $q) // delete all for this floor
                ->delete();
        }

        // delete removed floors (and apartments cascade)
        ProjectFloor::where('project_id', $project->id)
            ->when(count($keepFloorIds) > 0, fn($q) => $q->whereNotIn('id', $keepFloorIds))
            ->when(count($keepFloorIds) === 0, fn($q) => $q)
            ->delete();
        $audit->details='Updating project ('.$project->name.') succeeded';
        $audit->save();
        return redirect()
            ->route('apartments.existing-projects')
            ->with('success', 'Project updated successfully.');
    });
    }
public function deleteProject(Project $project)
{
    $audit=new AuditLog();
        $audit->user_id=auth()->id();
        $audit->event='Delete';
        $audit->entity_type='Project';
        $audit->details='Deleting project ('.$project->name.') failed';
        $audit->save();
        $audit->record='PRJ-'.str_pad(auth()->id(), 5, '0', STR_PAD_LEFT).'-'.$audit->id;
        $audit->save();
    $hasSold = $project->floors()
    ->whereHas('apartments', fn ($q) => $q->where('status', 'sold'))
    ->exists();

if ($hasSold) {
    return back()->with([
        'error' => 'Cannot delete a project with sold apartments.'
    ]);
}

    return DB::transaction(function () use ($project,$audit) {

        // Load relations we need
        $project->load([
            'inventoryUsages', // project_inventory_items
            'floors.apartments',
        ]);

        /**
         * 1️⃣ Restore inventory stock
         */
        foreach ($project->inventoryUsages as $usage) {
            $inventory = InventoryItem::where('id', $usage->inventory_item_id)
                ->lockForUpdate()
                ->first();

            if (!$inventory) continue;

            $restoreQty = (float) ( $usage->quantity_needed ?? 0);

            if ($restoreQty > 0) {
                $inventory->quantity += $restoreQty;
                $inventory->is_out_of_stock = $inventory->quantity <= 0;
                $inventory->save();
            }
        }

        /**
         * 2️⃣ Delete pivot (materials)
         */
        DB::table('project_inventory_items')
            ->where('project_id', $project->id)
            ->delete();

        /**
         * 3️⃣ Delete apartments
         */
        foreach ($project->floors as $floor) {
            $floor->apartments()->delete();
        }

        /**
         * 4️⃣ Delete floors
         */
        $project->floors()->delete();

        /**
         * 5️⃣ Delete project
         */
        $project->delete();
        $audit->details='Deleting project ('.$project->name.') succeeded';
        $audit->save();
        return redirect()
            ->route('apartments.existing-projects')
            ->with('success', 'Project deleted successfully.');
    });
}
}